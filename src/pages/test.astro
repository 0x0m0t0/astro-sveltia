<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Rolling Pin Effect</title>
		<style>
			body {
				height: 200vh; /* To allow scrolling */
				margin: 0;
				display: flex;
				justify-content: center;
				align-items: flex-start;
				background-color: #f0f0f0;
			}
			.image-container {
				margin-top: 0; /* Remove margin-top */
				width: 100%;
				height: 100vh; /* Make the container take full height of the viewport */
				overflow: hidden;
				position: relative;
			}
			canvas {
				width: 100%;
				height: auto; /* Ensure the image aspect ratio is maintained */
				position: fixed;
				top: 0;
				left: 0;
			}
		</style>
	</head>
	<body>
		<!-- Container for the image -->
		<div class="image-container">
			<!-- Canvas to display the transformed image -->
			<canvas id="canvas"></canvas>
		</div>

		<script>
			// Get the canvas element
			const canvas = document.getElementById('canvas')
			// Get the canvas context
			const ctx = canvas.getContext('2d')

			// Create an image element
			const img = new Image()
			// Set the source of the image
			img.src = 'assets/media/reservoir019.jpg' // Replace with your image path

			// Function to execute once the image is loaded
			img.onload = function () {
				// Set canvas size to match image aspect ratio
				canvas.width = window.innerWidth
				canvas.height = window.innerWidth * (img.height / img.width)
				// canvas.style.transform = 'rotate(90deg)' // or -90 depending on need
				// canvas.style.webkitTransform = 'rotate(90deg)'
				// Function to draw the transformed image
				function draw(ang, tilt, perspective) {
					// Clear the canvas
					ctx.clearRect(0, 0, canvas.width, canvas.height)
					// Calculate the step size based on canvas width
					const step = 1 / canvas.width
					// Loop through the width of the canvas
					for (let i = 0; i < 1; i += step) {
						// Calculate the angle for the current pixel
						const a = Math.PI - (i * Math.PI + ang * Math.PI * 2)
						const a1 = Math.PI - ((i + step * 2) * Math.PI + ang * Math.PI * 2)
						// Calculate the coordinates for the current pixel
						const ix = i * img.width
						const iw = step * img.width
						const x = canvas.width * 0.5
						const y = canvas.height * 0.1

						// Calculate the coordinates for the transformed pixel
						const x1 = x + Math.cos(a + Math.PI / 2) * 220 // Increased width by changing 110 to 820
						const y1 = y + Math.sin(a + Math.PI / 2) * tilt
						const x2 = x + Math.cos(a1 + Math.PI / 2) * 220 // Increased width by changing 110 to 820
						const y2 = y + Math.sin(a1 + Math.PI / 2) * tilt
						const s = Math.sin(a1 + Math.PI / 2)
						const s1 = Math.sin(a + Math.PI / 2)

						// Draw the transformed pixel on the canvas
						if (s > 0 || s1 > 0) {
							ctx.drawImage(
								img,
								ix,
								0,
								iw,
								img.height,
								x1,
								y - s * perspective * 0.5,
								x2 - x1,
								canvas.height + s * perspective
							)
						}
					}
				}

				// Function to update the animation
				function update() {
					// Get the current scroll position
					const scrollPosition = window.scrollY
					// Calculate the angle based on scroll position
					const ang = scrollPosition / 2000
					// Draw the transformed image
					draw(ang, 40, 30)
					// Request the next frame of animation
					requestAnimationFrame(update)
				}

				// Start the animation
				update()
			}
		</script>
	</body>
</html>
